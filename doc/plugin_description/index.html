<html>
<center>
	<img src="../../img/Phylogeny_cafe.jpg" width=300 height=81>
	<br>
	<font size="24" face="Times" color="3526a0"><i>StatAlign</i></font>
	<br>
	<font face="Times" color="000000"><i>(c) 2008 &Aacute;d&aacute;m 
	Nov&aacute;k, Istv&aacute;n Mikl&oacute;s, Rune Lyngsoe,  Jotun Hein</i></font>
	<br>
	<font face="Times" color="000000"><i>(c) 2012 Preeti Arunapuram, Ing&oacutelfur E&eth;var&eth;sson, Michael Golden, James Anderson</i></font>
</center>
<br>
<br>
<a name="contents">
<h1>Contents</h1>
	[<a href="#introduction">Introduction</a>]<br>
	[<a href="#model">Adding substitution models</a>]<br>
	[<a href="#postprocess">Developing additional postprocessing panels</a>]<br>
	
<!--------------------------------------------------------------------------------------------------->
<a name="introduction">
<h1>Introduction</h1>

	<p align="justify">
	This help page is for developers, and describes how to implement 
	additional substitution models and postprocessing panels.
	You do not have to understand this help file if you only would like
	use <i>StatAlign</i>. The help page for users can be found 
	<a href="../help/index.html">
	here
	</a>.</p>
	
<!--------------------------------------------------------------------------------------------------->
<a name="model">
<h1>Adding substitution models</h1>
	[<a href="#fields">Description of the fields in <tt>SubstitutionModel</tt></a>]<br>
	[<a href="#methods">Description of the methods of <tt>SubstitutionModel</tt></a>]

	<p align="justify">
	A novel substitution model has to extend the abstract class 
	<tt>SubstitutionModel</tt>. Once such a descendant class is developed its
	compiled class should be copied into the 
	<tt>statalign.model.subst.plugins</tt> sub-package. <i>StatAlign</i>
	automatically recognizes any novel substitution model. Recognized models
	can be seen on the <tt>Model</tt> menu, and can be selected as the accompanying
	model of the insertion-deletion model.</p>

	<a name="fields">
	<h2>Description of the fields in <tt>SubstitutionModel</tt></h2>

		<p align="justify">
		<u><b><tt>double[][]</tt> v, w, <tt>double[]</tt> d</b></u><br>
		The rate matrix must be diagonalized and represented in a
	 	<b>v d w</b> product, where <b>d</b> is a diagonal matrix.
	 	<b>v</b> and <b>w</b> are two dimensional arrays, <b>d</b>
	 	is a one dimensional double array containing the diagonal values
	 	(ie., the eigenvalues). Indexes of the arrays should agree with the
	 	representation of characters, namely numbers in index 0 should
	 	correspond to the character of the alphabet having code 0, etc.
	 	<br><br>
		
		<u><b><tt>double[]</tt> e</b></u><br>
		The one dimensional double array, <b>e</b> contains the 
		equilibrium probabilities. Indexing should be equivalent with 
		the indexing of arrays <b>v, w </b> and <b>d</b>.
		<br><br>
		
		<u><b><tt>char[]</tt> alphabet</b></u><br>
		The one dimensional char array gives the list of possible characters
		that the model accepts. Used in writing nexus alignments.
		<br><br>
		
		<u><b><tt>double[]</tt> parameters</b></u><br>
		The one dimensional double array contains the parameters of the model.
		The corresponding methods must be aware which parameter is available
		at which index.
		<br><br>
		
		<u><b><tt>String</tt> type</b></u><br>
		This String tells if it is a nucleic acid model or protein model.
		Used at creating nexus alignments and also at sorting models in the
		Models menu. In the Models menu, first models with type "protein" are
		listed then the models with type "nucleotide", and then the rest. Currently the
		'rest' part is empty.
		<br><br>
		
		<u><b><tt>SubstitutionModel</tt> attachedScoringScheme</b></u><br>
		This <tt>SubstitutionScore</tt> tells the corresponding 
		substitution score class. Note that this class will transform the
		characters in the input sequences into arrays containing Felsenstein's
		likelihoods. There are two substitution score classes available at the moment
		in <i>StatAlign</i>. The Blosum62 class implements the BLOSUM 62 scoring
		matrix and transforms non-ambiguous IUPAC one-letter amino acid codes into
		Felsentein's likelihood arrays. The DNAScore class implements a simple
		scoring matrix for nucleic acids, and transforms ambiguous and non-ambiguous
		IUPAC one-letter nucleic acid codes into Felsentein's likelihood arrays.
		Codon models are not supported directly in the current version of
		<i>StatAlign</i>. A possible indirect way would be to first transform
		coding DNA sequences into one-letter codon codes (three nucleic acids are
		represented by a single character), and to implement both a
		codon SubstitutionScore class that recognizes this one-letter code, 
		and a corresponding SubstitutionModel class.
		<br><br>
		</p>
		
	<a name="methods">
	<h2>Description of the methods of <tt>SubstitutionModel</tt></h2>

		<p align="justify">
		<u><b><tt>double</tt> acceptable(<tt>RawSequences</tt> r)</b></u><br>
		This function decides if it can accept a set of sequences represented as 
		RawSequences. r.sequences is a String array that contain the input sequences.
		This function might throw a RecognizingError, such a thrown error is
		handled by the MainFrame, and yields a pop-up window with the error message.
		The standard construction of RecognizingError is this if the
		<i>j</i>th character from the <i>i</i>th sequence cannot be recognized:
		</p>
		<pre>
throw new RecognizingError(getMenuName()+" cannot accept the sequences because it contains character '"+r.sequence[i].charAt(j)+"'!\n");
		</pre>
		If the model can accept sequences, then it returns with a number with between 0 and
		1, depending on how much the model likes the sequences. For example, sequences
		containing only 'a's and 'c's might be both DNA and protein sequences, though it
		is more likely that they are DNA sequences.
		<br><br>

		<p align="justify">
		<u><b><tt>String</tt> getMenuName()</b></u><br>
		This function should return with a String containing the name of the model.
		This name will appear in the menu <tt>Model</tt>.
		<br><br>
		
		<p align="justify">
		<u><b><tt>double</tt> sampleParameter()</b></u><br>
		This function should propose a change in the parameters and should return with
		the logarithm of quotient of backproposal and proposal probabilities.
		The <b>v, w, d</b> matrices and the equilibrium array <b>e</b> must be apdated
		according to the proposed parameters. Old values of the parameters
		must be stored in case of rejection of the proposal.
		<br><br>
		
		<p align="justify">
		<u><b><tt>void</tt> restoreParameter()</b></u><br>
		This function has to restore the old parameter values and 
		the <b>v, w, d</b> matrices and the equilibrium array <b>e</b> accordingly.
		<br><br>
		
		<p align="justify">
		<u><b><tt>String</tt> print()</b></u><br>
		This function returns with a String reporting the current parameter values.
		<br><br>
		
		<p align="justify">
		<u><b><tt>Color</tt> getColor(<tt>char</tt> c)</b></u><br>
		This function returns with the background color of character c. Used at
		printing alignments on the screen.
		<br><br>
		
		<p align="justify">
		<u><b><tt>char</tt> mostLikely(<tt>double[]</tt> seq)</b></u><br>
		This function receives a Felsenstein's likelihood array and returns with
		the most likely character. Used at printing alignments, for example, in
		ancestral nodes of the tree.
		<br><br>

<!--------------------------------------------------------------------------------------------------->
<a name="postprocess">
<h1>Developing additional postprocessing panels</h1>
	[<a href="#fields_postprocess">Description of the fields in <tt>Postprocess</tt></a>]<br>
	[<a href="#methods_postprocess">Description of the methods of <tt>Postprocess</tt></a>]<br>
	[<a href="#examples">Examples</a>]

	<p align="justify">
	A novel postprocessing class has to extend the abstract class 
	<tt>Postprocess</tt>. Once such a descendant class is developed its
	compiled class should be copied into the 
	<tt>statalign.postprocess.plugins</tt> sub-package. <i>StatAlign</i>
	automatically recognizes any novel postprocessing method. Recognized methods
	has a tabulated panel and added to the main frame. They also can be selected
	to generate their own output file in the Output preferences pop-up window.</p>

	<a name="fields_postprocess">
	<h2>Description of the fields in <tt>Postprocess</tt></h2>

		<p align="justify">
		<u><b><tt>boolean</tt> selected</b></u><br>
		True if plugin is selected in the menu (and thus a tab is created for the plugin in
	 	the main window that can be used to allow the user to change settings before MCMC
	 	start and to show runtime information afterwards).
	 	<br><br>

		<p align="justify">
		<u><b><tt>boolean</tt> screenable</b></u><br>
		True if it <u>can</u> generate a GUI. Not used in the current version, it is
	 	for further development if one wants to switch on and off the GUIs.
	 	<br><br>
	 	
		<p align="justify">
		<u><b><tt>boolean</tt> active</b></u><br>
		True if plugin is active (must produce its output) either because other plugins depend
	 	on it or because it is selected.
	 	<br><br>
	 	
		<p align="justify">
		<u><b><tt>boolean</tt> outputable</b></u><br>
		True if this class <u>can</u> generate an output.
	 	<br><br>

		<p align="justify">
		<u><b><tt>boolean</tt> postprocessable</b></u><br>
		True if this class <u>can</u> generate a postprocess file.
	 	<br><br>
	 	
		<p align="justify">
		<u><b><tt>boolean</tt> sampling</b></u><br>
		True if it writes into the log file.
	 	<br><br>
	 	
		<p align="justify">
		<u><b><tt>boolean</tt> postprocessWrite</b></u><br>
		True if it writes a postprocess file.
	 	<br><br>
	 	
		<p align="justify">
		<u><b><tt>String</tt> alignmentType</b></u><br>
		This string tells the alignment type in which alignment must be presented.
	 	<br><br>
	 	
		<p align="justify">
		<u><b><tt>FileWriter</tt> file</b></u><br>
		This is the logfile writer that is written during the running and gets information from 
	 	all postprocesses.
	 	<br><br>
	 	
		<p align="justify">
		<u><b><tt>FileWriter</tt> outputFile</b></u><br>
		This is the output file writer, that is written by a specific postprocess plugin.
	 	<br><br>

		<p align="justify">
		<u><b><tt>Mcmc</tt> mcmc</b></u><br>
		This is the current Mcmc object. Use this to access the current state of the Mcmc
	 	via mcmc.tree.
	 	<br><br>

	<a name="methods_postprocess">
	<h2>Description of the methodss in <tt>Postprocess</tt></h2>

		<p align="justify">
		<u><b><tt>String</tt> getTabName()</b></u><br>
		This function returns with the name of the method. This will 
		written to the tab of its panel.
	 	<br><br>
	 	
		<p align="justify">
		<u><b><tt>Icon</tt> getIcon()</b></u><br>
		This function returns with the icon of the method. This will 
		appear on the tab of its panel.
	 	<br><br>
	 	
		<p align="justify">
		<u><b><tt>JPanel</tt> getJPanel()</b></u><br>
		Returns with the panel of the GUI. If necessary, the developers can
		develop their plugin's own GUI, w esuggest that such a GUI be put into
		the statalign.postprocess.gui subpackage.
	 	<br><br>

		<p align="justify">
		<u><b><tt>String</tt> getTip()</b></u><br>
		Returns with the tip information (shown when the mouse cursor is moved over the 
	 	label of the tabulated panel).
	 	<br><br>

		<p align="justify">
		<u><b><tt>String[]</tt> getDependences()</b></u><br>
		Override this and return an array of full-qualified class names of the plugins
	 	this plugin depends on.
	 	<br><br>

		<p align="justify">
		<u><b><tt>void</tt> refToDependences(<tt>Postprocess[]</tt> plugins)</b></u><br>
		Override this to get access to instances of the plugins your plugin depends on.
	 	This function will be called by the PostprocessManager during its initialisation.
	 	The parameter plugins is a reference to Postprocess objects in the order 
	 	they are specified in getDependences() or null if getDependences() returns with null.
	 	<br><br>

		<p align="justify">
		<u><b><tt>void</tt> beforeFirstSample()</b></u><br>
		Called before the MCMC starts. This is the first time the prostprocess plugin can 
		use PostprocessManager.mcmc to access internal data structure.
		<br><br>

		<p align="justify">
		<u><b><tt>void</tt> newStep()</b></u><br>
		Called whenever a new step is made. A typical run of MCMC takes hundred thousands of
	 	steps, override this function only if it takes a negligible amount of time and does not
	 	use too much memory. We use, for example, in drawing the loglikelihood trace.
		<br><br>

		<p align="justify">
		<u><b><tt>void</tt> newSample(<tt>int</tt> no, <tt>int</tt> total)</b></u><br>
		This function is called when we sample from the Markov chain.
	 	Parameter no is the number of the current sample, total is the number 
	 	of the total samples.
	 	<br><br>

		<p align="justify">
		<u><b><tt>void</tt> setSampling(<tt>boolean</tt> enabled)</b></u><br>
		This function switches on or off the sampling mode. The parameter 
		enabled is set to true if samples are needed.	 	
		<br><br>

		<p align="justify">
		<u><b><tt>void</tt> afterLastSample()</b></u><br>
		This function is called after the MCMC runs.	 	
		<br><br>

	<a name="examples">
	<h2>Examples</h2>

		<ul>
			<li><p align="justify">
				The <tt>MpdAlignment</tt> plugin is screenable, outputable and
				postprocessable. The <tt>CurrentAlignment</tt> plugin is
				screenable, outputable, but not postprocessable.
			</li>

			<li><p align="justify">
				The <tt>CurrentAlignment</tt> and <tt>MpdAlignment</tt> plugins
				use the same GUI, the <tt>AlignmentGUI</tt> class.
			</li>

			<li><p align="justify">
				The <tt>LogLikelihoodTrace</tt> plugin uses a <tt>LogLikelihoodTraceContainer</tt>
				class to store information about loglikelihoods and whether the 
				loglikelihood value comes from a burn-in phase or after burn-in.
				The Mcmc class has a public boolean variable burnin which is true if the
				MCMC run is in the burn-in phase.
			</li>

			<li><p align="justify">
				If you would like to develop a plugin that predicts secondary structures
				mapping one known structure to other sequences, you can create a plugin that
				depends on the <tt>CurrentAlignment</tt> plugin. <tt>CurrentAlignment</tt>
				has two public String arrays, allAlignment and leafAlignment from which you
				can read the multiple alignment of all sequences (both at the leaves of the
				tree and at the internal nodes) and the multiple alignment of sequences
				at the leaves.<br>
				
				You can use the beforeFirstSample() function to interact with the users and
				ask for an additional file from which the known secondary structures might 
				be read.
			</li>


		</ul>
</html>